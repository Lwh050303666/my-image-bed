---
title: 动静态库
date: 2025-05-28 23:48:07
tags:
---
# 知识点大杂烩 
- ctrl+~ 可以打开vscode的终端
- 所谓的"虚拟地址"和"逻辑地址"本质上是一回事，只不过在磁盘中被称为"逻辑地址",到了内存中就成了"虚拟地址".

![](/2025/05/28/动静态库/71b33231049b92bae9481d863304955.png) 

![](/2025/05/28/动静态库/7d3bdcb2cac9be71f915da553b52798.png)

上图为不同进程对同一动态库的链接方式

![](/2025/05/28/动静态库/89bc03a8e30d0f2d0d1650152f37ba2.png)

![](/2025/05/28/动静态库/3dd578797f4951627e975529cce933d.png)

![](/2025/05/28/动静态库/cf116e7a0de32e1776d815187a9229b.png)

![](/2025/05/28/动静态库/1b1c953f82b4406d50ed801294b19d5.png)


1. 局部性原理：在计算机科学中，程序在执行时，倾向于重复访问最近使用过的数据或指令，以及与当前访问位置相邻的数据和指令。这种重复性访问模式使得程序在运行过程中，可以被预测和优化，从而提高系统的性能。
2. linux中，我们的每一个进程，打开的每一个文件都要有自己的inode属性和自己的文件页缓冲区
3. *.a表示静态库  *so表示动态库
linux中的编译器默认使用动态链接
4. c语言中形参的实例化是从右向左执行的
![](/2025/05/28/动静态库/b1b7bdba90f46092a45c7a8b22e6532.jpg) 

上图中的"myerrno"变量永远是初始值，因为printf函数中形参从右向左执行，先确定了myerrno的值才执行函数。
![](/2025/05/28/动静态库/bf13e8beb6fc79d3a8ffa73467d5191.jpg)  
上面这张图才是正确的做法

# 静态库
![](/2025/05/28/动静态库/11d0210ed132f3ad232a1ca8ca9b583.png)

![](/2025/05/28/动静态库/d2771e23af21e6dc98a4260d4682759.png)

如图是我写的几个程序，我们想要静态库的实现和链接功能。图中的"output"代表库的发布

![](/2025/05/28/动静态库/770df19989715694d553eb34f064886.png)    
![](/2025/05/28/动静态库/c2b55acc7e1e2cf7cc96828715c6fec.png) 

如图是我在另一个目录下创建的文件，可以看到文件出现了链接错误的情况。为什么呢？
本质原因在于编译器找不到头文件，有的人会问main中不是包含有头文件而且lib下不是有头文件吗，为什么找不到呢？那是因为linux中编译器只会默认在系统和当前目录下进行查找。（有的人会问，当前目录下不是有lib文件吗，里面不是有库的实现吗？非也非也，我们所说的 **"当前目录"**指的是和源代码同一个路径，这里的lib目录下的头文件和main显然不属于同一个目录。

所以我们应该怎么做呢？
1. 方法一：把头文件直接写到系统目录中
2.![](/2025/05/28/动静态库/ab6780bd87f2d9a7cc861118a662729.png)
方法二：我们可以通过指令指定系统去搜索头文件路径，"-I"用来指定头文件的搜索路径，然而，对于库来说，系统默认只会搜索系统自带的c的库，-L"就是指定库路径，然而光指定库的路径还是不行，**指定了库的路径以后万一这个路径下有很多的库怎么办？**因此我们还得指定库的名称，"-l"就是指定库的名称，最好将"-l"和库的名称直接连起来，这样可以防止系统错将空格也识别为库名，需要注意的是，库的真实名字是去掉前缀和后缀的。
# 动态库
![](/2025/05/28/动静态库/57ddcb3b09f1b61c7a3a7516fff096e.png)

如图是生成动态库的相关指令
gcc -fPIC -c(生成二进制文件) file(原文件)  (-o file)(可有可无)      不指明目标文件的话默认生成与file同名的".o"文件

![](/2025/05/28/动静态库/fe618d168702f0d30a0d0d359742ed1.png)

然而，如上图所示，动态链接有个小问题，你 gcc -I -L -l 在指定路径编译后程序在链接时会报错。原因:你上面指定路径是给编译器看的，在形成了可执行程序a.out准备运行时已经和编译器没有关系了，这和系统有关，因此得把路径移动到系统的默认路径下。 **大体有以下几种方式**

1. 拷贝到系统默认的库路径/usr/lib64
2. 在系统默认的库路径usr/lib64下建立软链接
3. 将自己的库的路径，添加到系统的环境变量 LD_LIBRARY_PATH中，不用写名称，因为我们在上面gcc -I -L -l时已经写了库名称。
4. /etc/ld.so.conf.d目录下建立自己的动态库路径的配置文件，然后重新执行Ldconfig命令即可。  注意：一个配置文件里放一个完整的库的路径

- 动态库在系统中加载之后会被所有进程共享 
- 程序在编译时就有地址了
- 生成的静态库是不可执行的，因为静态库的功能就是给其他要链接的程序提供一份代码，但动态库是可执行的，因为动态库要和可执行程序产生关联，这就意味着动态库必定要被加载。
- 进程地址空间：我们常常会有这样的疑惑：动态库在磁盘中使用的是硬编码，所以它只能访问硬编码所对应的地址，意味着是固定的，必须被加载到共享区的特定地址，那这显然不合适，进程那么多，为什么你能提前占位置呢？所以真正的静态库可以在虚拟内存共享区的任意位置占用空间，而让原库的内部函数不要采用绝对编制，只表示每个函数在库中的偏移量即可


# 每日算法题
## 第一题

![](/2025/05/28/动静态库/4802a948569ef6fe75bf56bddaace51.png)

这段代码是用 **滑动窗口算法** 实现的 **“最小覆盖子串”问题** 的解法，即：

> 给定字符串 `s` 和字符串 `t`，返回 `s` 中包含所有 `t` 中字符的最小子串（字符可以重复，顺序不限）。

---

## ✅ 代码功能

实现了 LeetCode 第 76 题：**Minimum Window Substring**

---

## 🧠 核心思想：滑动窗口 + 哈希表

* `ori`：统计字符串 `t` 中每个字符出现的次数
* `cnt`：当前窗口中，每个目标字符的计数
* `check()`：判断当前窗口 `cnt` 是否满足 `ori` 的所有要求（即是否包含了 `t` 中所有字符）

---

## 🧩 代码逐步解析

```cpp
unordered_map <char, int> ori, cnt;
```

* `ori` 保存 `t` 中每个字符需要的出现次数。
* `cnt` 保存当前窗口中包含的字符和出现次数。

---

### `check()` 函数

```cpp
bool check() {
    for (const auto &p: ori) {
        if (cnt[p.first] < p.second) {
            return false;
        }
    }
    return true;
}
```

* 遍历 `ori` 所需的所有字符，只要当前窗口的 `cnt` 中任意一个字符数量不足就返回 `false`。

---

### 初始化

```cpp
for (const auto &c: t) {
    ++ori[c];
}
```

* 统计字符串 `t` 中字符的频次。

---

### 滑动窗口主逻辑

```cpp
int l = 0, r = -1;
int len = INT_MAX, ansL = -1, ansR = -1;

while (r < int(s.size())) {
    if (ori.find(s[++r]) != ori.end()) {
        ++cnt[s[r]];
    }
```

* `r` 从 `-1` 开始，每次右移扩大窗口。
* 如果当前字符 `s[r]` 是 `t` 中的目标字符之一，就更新计数器 `cnt`。

---

### 尝试收缩窗口

```cpp
    while (check() && l <= r) {
        if (r - l + 1 < len) {
            len = r - l + 1;
            ansL = l;
        }
        if (ori.find(s[l]) != ori.end()) {
            --cnt[s[l]];
        }
        ++l;
    }
```

* 当前窗口满足 `t` 的要求时，尝试缩小窗口：

  * 如果新窗口更短，则更新最小区间的起始位置 `ansL` 和长度 `len`
  * 收缩窗口左边 `l++`，并更新 `cnt`

---

### 返回结果

```cpp
return ansL == -1 ? string() : s.substr(ansL, len);
```

* 如果没有满足条件的窗口，返回空串
* 否则返回长度最短的合法子串

---

## 🧪 举个例子

`s = "ADOBECODEBANC"`
`t = "ABC"`

执行过程将返回：`"BANC"`

---

## ✅ 时间复杂度分析：

* 遍历 `s` 一次，每个字符最多进出窗口一次：

  * 时间复杂度：**O(n)**，其中 `n` 为 `s.length()`
* `check()` 每次都要遍历 `t` 中字符，最坏是 O(m)

  * 所以总复杂度是：**O(n \* m)**，但因 `t` 通常较短，可近似为 **O(n)**

---

## 第二题
![](/2025/05/28/动静态库/673170b9df703c211db0d88461042f8.png)
## 第三题
![](/2025/05/28/动静态库/a4d009747f5e24e2fb2c03be70e549c.png)
#include <iostream>     // 用于 cin/cout 输入输出
#include <vector>       // 使用 vector 容器
using namespace std;

int main() {
    int n, a, b;
    cin >> n;                   // 输入数组长度 n
    vector<int> vec(n);         // vec 数组，存储输入的原始数据
    vector<int> p(n);           // p 数组，存储前缀和
    int presum = 0;             // 用于计算前缀和的累加变量

    // 输入数组的每一个元素，并同时计算前缀和
    for (int i = 0; i < n; i++) {
        scanf("%d", &vec[i]);   // 输入每个整数（使用 scanf 效率更高）
        presum += vec[i];       // 累加当前值
        p[i] = presum;          // 把当前的前缀和保存到 p[i]
    }

    // 处理多个查询，每个查询给出 a 和 b，表示查询 vec[a] 到 vec[b] 的区间和
    // ~scanf(...) 是 scanf(...) != EOF 的写法，即直到文件结尾或输入中断
    while (~scanf("%d%d", &a, &b)) {
        int sum;

        // 如果查询从 a = 0 开始，直接取 p[b]（从 vec[0] 到 vec[b] 的和）
        if (a == 0) sum = p[b];
        else sum = p[b] - p[a - 1]; // 否则使用前缀和计算 vec[a] 到 vec[b] 的区间和

        printf("%d\n", sum);    // 输出当前查询的区间和
    }
}



